<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="author" content="brookr (https://6529.io/brookr)" />
  <meta name="source" content="https://github.com/brookr/eth-light" />
  <title>Eth Light</title>
  <link rel="stylesheet" href="tangerine.css">
  <style>
    html, body { margin:0; height:100%; background:#050408; overflow:hidden; }
    body { touch-action:none; }
    #wrap {
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
    }
    canvas { display:block; background:transparent; }
  </style>
</head>
<body>
  <div id="wrap"><canvas id="c"></canvas></div>
<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // ---------- 5:7 portrait fit-to-viewport ----------
  function resize() {
    const vw = innerWidth, vh = innerHeight;
    const targetAspect = 5/7;         // width/height
    let cssW, cssH;
    if (vw / vh > targetAspect) {
      cssH = vh;
      cssW = Math.floor(vh * targetAspect);
    } else {
      cssW = vw;
      cssH = Math.floor(vw / targetAspect);
    }
    const dpr = Math.max(1, devicePixelRatio || 1);
    canvas.style.width = cssW + "px";
    canvas.style.height = cssH + "px";
    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
  }
  addEventListener("resize", resize);
  resize();

  // ---------- deterministic RNG (seeded) ----------
  // Seed from current Ethereum block number (fetched after rpc is defined)
  let seed = 2166136261; // FNV-1a offset basis (fallback)
  let seedInitialized = false;
  
  function rand() { // xorshift32
    seed ^= seed << 13; seed ^= seed >>> 17; seed ^= seed << 5;
    return ((seed >>> 0) / 4294967296);
  }
  function clamp01(x){ return x<0?0:x>1?1:x; }
  function smoothstep(a,b,x){
    x = clamp01((x-a)/(b-a));
    return x*x*(3-2*x);
  }

  // ---------- RPC & Burn Rate Logic ----------
  const RPC_URLS = [
    "https://cloudflare-eth.com",
    "https://ethereum-rpc.publicnode.com",
    "https://rpc.ankr.com/eth",
    "https://eth.llamarpc.com",
    "https://ethereum.blockpi.network/v1/rpc/public",
    "https://rpc.flashbots.net",
    "https://virginia.rpc.blxrbdn.com",
    "https://uk.rpc.blxrbdn.com",
    "https://singapore.rpc.blxrbdn.com",
    "https://rpc.mevblocker.io",
  ];

  function shuffled(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  async function fetchJson(url, bodyObj, timeoutMs = 6000) {
    const ac = new AbortController();
    const t = setTimeout(() => ac.abort(), timeoutMs);

    try {
      const res = await fetch(url, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(bodyObj),
        signal: ac.signal,
      });
      const json = await res.json();
      if (json.error) throw new Error(json.error.message || "RPC error");
      return json.result;
    } finally {
      clearTimeout(t);
    }
  }

  let cachedRpcUrl = null; // Cache successful RPC endpoint
  
  async function rpc(method, params = []) {
    if (globalThis.ethereum?.request) {
      return await ethereum.request({ method, params });
    }
    
    // Try cached URL first
    if (cachedRpcUrl) {
      try {
        return await fetchJson(cachedRpcUrl, { jsonrpc: "2.0", id: 1, method, params });
      } catch (e) {
        // Cached URL failed, clear it and try others
        cachedRpcUrl = null;
      }
    }
    
    // Try all URLs in random order
    const urls = shuffled(RPC_URLS);
    let lastErr;
    for (const url of urls) {
      try {
        const result = await fetchJson(url, { jsonrpc: "2.0", id: 1, method, params });
        cachedRpcUrl = url; // Cache successful URL
        console.log(`Using endpoint: ${url}`);
        return result;
      } catch (e) {
        lastErr = e;
      }
    }
    throw lastErr || new Error("All RPC endpoints failed");
  }

  let burnRateTarget = 0.05; // Default "mid-range" brightness
  let pointerHovering = false;
  let touchActive = false;
  let lastBlockNumber = null; // Track last block to avoid duplicate logs

  function userIsControlling() {
    return pointerHovering || touchActive;
  }

  async function updateBurnRate() {
    try {
      const block = await rpc('eth_getBlockByNumber', ['latest', false]);
      if (block && block.baseFeePerGas) {
        const blockNumber = parseInt(block.number, 16);
        
        // Initialize RNG seed on first block (once per load)
        if (!seedInitialized) {
          seedInitialized = true;
          const seedStr = blockNumber.toString();
          seed = 2166136261;
          for (let i=0;i<seedStr.length;i++) seed = Math.imul(seed ^ seedStr.charCodeAt(i), 16777619);
          console.log(`RNG seeded with Ethereum block ${blockNumber}`);
        }
        
        // Skip if we've already processed this block
        if (blockNumber === lastBlockNumber) return;
        lastBlockNumber = blockNumber;
        // 1. Execution Burn
        const baseFeeWei = parseInt(block.baseFeePerGas, 16);
        const gasUsed = parseInt(block.gasUsed, 16);
        const executionBurnWei = BigInt(baseFeeWei) * BigInt(gasUsed);

        // 2. Blob Burn
        // blobBaseFeePerGas is often not in RPC, so we calc it from excessBlobGas
        // Formula: y = MIN_BLOB_GASPRICE * e^(excessBlobGas / BLOB_GASPRICE_UPDATE_FRACTION)
        // MIN_BLOB_GASPRICE = 1
        // BLOB_GASPRICE_UPDATE_FRACTION = 3338477
        let blobBurnWei = 0n;
        // Prefer explicit blobBaseFeePerGas if available (EIP-4844 / Pectra support)
        if (block.blobBaseFeePerGas) {
            const blobBaseFee = parseInt(block.blobBaseFeePerGas, 16);
            const blobGasUsed = block.blobGasUsed ? parseInt(block.blobGasUsed, 16) : 0;
            blobBurnWei = BigInt(blobBaseFee) * BigInt(blobGasUsed);
        }
        else {
            // Fallback: Fetch fee history to get the authentic blob fee
            // verified to be correct (~0.001 Gwei) vs the broken excessBlobGas formula (~0.003 ETH)
            try {
                const history = await rpc('eth_feeHistory', [1, 'latest', []]);
                if (history && history.baseFeePerBlobGas && history.baseFeePerBlobGas.length > 0) {
                     // The array includes the *next* block's fee at the end, so we take the recent one.
                     // usually history.baseFeePerBlobGas[0] corresponds to the requested block range start.
                     const blobBaseFee = parseInt(history.baseFeePerBlobGas[0], 16);
                     const blobGasUsed = block.blobGasUsed ? parseInt(block.blobGasUsed, 16) : 0;
                     blobBurnWei = BigInt(blobBaseFee) * BigInt(blobGasUsed);
                }
            } catch (err) {
                console.warn("Failed to fetch fee history fallback", err);
            }
        }

        // 3. Total Burn (ETH)
        // We use BigInt for precision, then convert to Number for brightness calc
        const totalBurnWei = executionBurnWei + blobBurnWei;
        const totalBurnEth = Number(totalBurnWei) / 1e18;

        // 4. Brightness Mapping (Logarithmic)
        // Midpoint: 0.00045 ETH total block burn (~0.03 Gwei base fee / Solstice 2025 Baseline)
        // Range: 0.03 Gwei (50% bright) â†’ 10 Gwei (100% bright)
        // Fetches real base fee from RPC, calculates actual burn per block
        const mid = 0.00045; 
        const rangeScale = 333; // 333x range spans 0.03 to 10 Gwei
        const slope = 0.5 / Math.log(rangeScale);
        
        let brightness = 0.5 + slope * Math.log(Math.max(0.000001, totalBurnEth) / mid);
        brightness = clamp01(brightness);

        // yNorm is 0 at top (bright), 1 at bottom (dim).
        // So target = 1.0 - brightness
        if (!userIsControlling()) {
            burnRateTarget = 1.0 - brightness;
        }

        console.log(`Block ${blockNumber}: ${totalBurnEth.toFixed(4)} ETH burn, brightness ${brightness.toFixed(2)}`);
      }
    } catch (e) {
      console.warn("Burn rate fetch failed", e);
    }
  }
  
  // Initial fetch and loop
  updateBurnRate();
  setInterval(updateBurnRate, 12000);

  // ---------- TDH Vote Tracking for 6529 Main Stage (Top 50 by Rank) ----------
  const WAVE_ID = "b6128077-ea78-4dd9-b381-52c4eadb2077";
  const PAGE_SIZE = 50;
  const PAGE = 1;
  const SORT = "RANK";
  const SORT_DIRECTION = "ASC";
  const POLL_MS = 12000;
  const WINDOW_MS = 3600000; // 1 hour
  const SCORE_FIELD = "realtime_rating";
  
  const leaderboardUrl = () =>
    `https://api.6529.io/api/waves/${WAVE_ID}/leaderboard` +
    `?page_size=${PAGE_SIZE}&page=${PAGE}&sort=${SORT}&sort_direction=${SORT_DIRECTION}`;
  
  const lastScoreById = new Map();
  let events = [];
  let voteActivityScale = 0.0; // 0.0 = no activity, 1.0+ = high activity (logarithmic)
  let voterCount = 0; // number of unique voters in last hour
  
  async function pollVotes() {
    const now = Date.now();
    events = events.filter((e) => now - e.t <= WINDOW_MS);
    
    let json;
    try {
      const res = await fetch(leaderboardUrl());
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      json = await res.json();
    } catch (e) {
      console.log(`[${new Date().toLocaleTimeString()}] TDH fetch error`, e);
      return;
    }
    
    const drops = Array.isArray(json.drops) ? json.drops : [];
    const currentIds = new Set();
    
    for (const d of drops) {
      const id = d.id;
      currentIds.add(id);
      const score = Number(d?.[SCORE_FIELD] ?? 0);
      const prev = lastScoreById.get(id);
      if (prev === undefined) {
        lastScoreById.set(id, score);
        continue;
      }
      const delta = score - prev;
      if (delta !== 0) {
        events.push({
          t: now,
          id,
          rank: d.rank,
          title: d.title || "(untitled)",
          author: d?.author?.handle || "(unknown)",
          delta,
          newScore: score,
        });
        lastScoreById.set(id, score);
      }
    }
    
    // Cleanup: remove IDs that fell out of top 50 to prevent unbounded Map growth
    for (const id of lastScoreById.keys()) {
      if (!currentIds.has(id)) {
        lastScoreById.delete(id);
      }
    }
    
    // Count unique voters (submissions with activity) in last hour
    const uniqueSubmissions = new Set(events.map(e => e.id));
    voterCount = uniqueSubmissions.size;
    
    // Aggregate deltas over last hour
    const agg = new Map();
    for (const e of events) {
      const cur = agg.get(e.id) || {
        title: e.title,
        author: e.author,
        rank: e.rank,
        netDelta: 0,
        newScore: e.newScore,
      };
      cur.netDelta += e.delta;
      cur.newScore = e.newScore;
      cur.rank = e.rank;
      agg.set(e.id, cur);
    }
    
    const rows = [...agg.values()]
      .filter((r) => r.netDelta !== 0)
      .sort((a, b) => Math.abs(b.netDelta) - Math.abs(a.netDelta));
    
    const totalInflow = rows.reduce((sum, r) => sum + r.netDelta, 0);
    
    // Logarithmic scaling for star size based on vote activity
    // 10K votes = 0.0 (midrange), 100K votes = 1.0 (upper-mid), 1M votes = 2.0, 2M votes = 2.3
    // Using log10 with a baseline of 10,000 TDH as "midrange" activity
    const baseline = 10000;
    if (totalInflow > 0) {
      voteActivityScale = Math.log10(Math.max(1, totalInflow) / baseline);
    } else {
      voteActivityScale = 0.0;
    }
    
    // Only log if there's activity
    if (voterCount > 0 || totalInflow > 0) {
      console.log(`TDH voted: ${totalInflow.toLocaleString()} from ${voterCount} submissions (${starPoints} points)`);
    }
  }
  
  pollVotes();
  setInterval(pollVotes, POLL_MS);

  // ---------- pointer/touch input ----------
  let yNormTarget = 0.5; // 0 top, 1 bottom
  let yNorm = 0.5;
  let xNormTarget = 0.5; // 0 left, 1 right
  let xNorm = 0.5;
  let starPoints = 4; // number of star points (base 4 + voter count)
  let resetTimer = null;
  let userOverridePoints = false; // track if user is manually controlling points
  let pointerDownX = 0;
  let pointerDownY = 0;
  let hasMoved = false;

  function setFromClientY(clientY) {
    const rect = canvas.getBoundingClientRect();
    const y = (clientY - rect.top) / Math.max(1, rect.height);
    yNormTarget = clamp01(y);
  }

  function setFromClientX(clientX) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) / Math.max(1, rect.width);
    xNormTarget = clamp01(x);
  }

  // Pointer events cover mouse + touch; touch-action none prevents scroll.
  canvas.addEventListener("pointerenter", (e) => {
    if (e.pointerType !== "touch") {
      pointerHovering = true;
      setFromClientY(e.clientY);
      setFromClientX(e.clientX);
    }
  });

  canvas.addEventListener("pointerdown", (e) => { 
    e.preventDefault(); 
    if (e.pointerType === "touch") touchActive = true;
    else pointerHovering = true;
    
    // Track starting position to detect tap vs slide
    pointerDownX = e.clientX;
    pointerDownY = e.clientY;
    hasMoved = false;
    
    setFromClientY(e.clientY);
    setFromClientX(e.clientX);
  }, {passive:false});
  
  canvas.addEventListener("pointermove", (e) => { 
    e.preventDefault(); 
    if (e.pointerType !== "touch") pointerHovering = true;
    
    // Detect if pointer has moved significantly (more than 5px)
    const dx = e.clientX - pointerDownX;
    const dy = e.clientY - pointerDownY;
    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
      hasMoved = true;
    }
    
    if (userIsControlling()) {
      setFromClientY(e.clientY);
      setFromClientX(e.clientX);
    }
  }, {passive:false});

  canvas.addEventListener("pointerup",   (e) => { 
    e.preventDefault(); 
    if (e.pointerType === "touch") touchActive = false;
    
    // Only add point if this was a tap (no movement)
    if (!hasMoved) {
      userOverridePoints = true;
      starPoints = Math.min(starPoints + 1, 42);
    }
    
    // Start/restart reset timer from touch-end (6.9 seconds after last release)
    if (resetTimer) clearTimeout(resetTimer);
    resetTimer = setTimeout(() => {
      userOverridePoints = false;
      starPoints = 4 + voterCount;
    }, 6900);
  }, {passive:false});

  canvas.addEventListener("pointercancel",(e)=> { 
    e.preventDefault(); 
    pointerHovering = false; 
    touchActive = false; 
  }, {passive:false});

  canvas.addEventListener("pointerleave",()=> { 
    pointerHovering = false; 
    touchActive = false; 
  });

  // ---------- geometry helpers ----------
  let cachedStarAngles = null;
  let cachedStarPoints = 0;
  let cachedStarRadiusPattern = null;
  
  function updateStarCache(points) {
    if (cachedStarPoints === points) return;
    
    // Cache angles and radius pattern
    cachedStarAngles = [];
    cachedStarRadiusPattern = [];
    const step = Math.PI / points;
    let a = -Math.PI / 2;
    
    for (let i=0;i<points*2;i++) {
      cachedStarAngles.push(a);
      if (i % 2 === 0) {
        // Outer points (arms): alternate between full length and shorter (70%)
        const armIndex = Math.floor(i / 2);
        cachedStarRadiusPattern.push((armIndex % 2 === 0) ? 1.0 : 0.7);
      } else {
        // Inner points: always use innerR
        cachedStarRadiusPattern.push(null); // Use innerR
      }
      a += step;
    }
    cachedStarPoints = points;
  }
  
  function starPath(cx, cy, outerR, innerR, points=5) {
    updateStarCache(points);
    
    ctx.beginPath();
    for (let i=0;i<cachedStarAngles.length;i++) {
      const angle = cachedStarAngles[i];
      const radiusPattern = cachedStarRadiusPattern[i];
      let r;
      if (radiusPattern === null) {
        r = innerR; // Inner points (pulsing)
      } else {
        r = outerR * radiusPattern; // Outer points (scaled)
      }
      const x = cx + Math.cos(angle) * r;
      const y = cy + Math.sin(angle) * r;
      if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
  }

  // Draw text along an arc, centered.
  function drawTextOnArc(text, cx, cy, radius, startAngle, endAngle, opts) {
    const { alpha=1, fill="#fff", fontPx=28, glow=false, align="center", clockwise=true } = opts || {};
    if (!text) return;

    // Convert hex to rgba for Safari compatibility
    let fillWithAlpha = fill;
    if (fill.startsWith('#')) {
      const r = parseInt(fill.slice(1,3), 16);
      const g = parseInt(fill.slice(3,5), 16);
      const b = parseInt(fill.slice(5,7), 16);
      fillWithAlpha = `rgba(${r},${g},${b},${alpha})`;
    }

    ctx.save();
    ctx.fillStyle = fillWithAlpha;
    ctx.font = `${fontPx}px "Tangerine", cursive`;
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";
    if (glow) {
      ctx.shadowColor = fillWithAlpha;
      ctx.shadowBlur = Math.max(2, fontPx * 0.6);
    } else {
      ctx.shadowBlur = 0;
    }

    const chars = [...text];
    const arc = endAngle - startAngle;
    const dir = clockwise ? 1 : -1;

    // approximate spacing by measuring each char
    const widths = chars.map(ch => ctx.measureText(ch).width);
    const total = widths.reduce((a,b)=>a+b,0);
    const pxPerRad = total / Math.max(0.001, Math.abs(arc)*radius);

    // map cumulative widths to angles
    let offset = 0;
    // Center the text in the arc:
    let angle = (startAngle + endAngle)/2 - dir * (total/(2*radius*pxPerRad)) * pxPerRad;

    for (let i=0;i<chars.length;i++) {
      const w = widths[i];
      const ang = angle + dir * (offset + w/2) / radius;
      const x = cx + Math.cos(ang) * radius;
      const y = cy + Math.sin(ang) * radius;

      ctx.save();
      ctx.translate(x,y);
      // rotate so letters are tangential
      ctx.rotate(ang + (clockwise ? Math.PI/2 : -Math.PI/2));
      ctx.fillText(chars[i], 0, 0);
      ctx.restore();

      offset += w;
    }
    ctx.restore();
  }

  // ---------- phrases ----------
  const TOP_TEXT = "a light shines in the darkness";
  const BOT_TEXT = "and the darkness has not overcome it";

  // ---------- animation ----------
  let t0 = performance.now();
  let flicker = 0.6; // smoothed brightness
  let cachedBgGradient = null;
  let lastW = 0, lastH = 0;

  let lastFrameTime = 0;
  const targetFrameTime = 1000 / 24; // 24fps
  
  function frame(now) {
    // Throttle to 24fps
    if (lastFrameTime > 0 && (now - lastFrameTime) < targetFrameTime) {
      requestAnimationFrame(frame);
      return;
    }
    lastFrameTime = now;
    
    const t = (now - t0) / 1000;

    // Update star points based on voter count (unless user is manually controlling)
    if (!userOverridePoints) {
      starPoints = 4 + voterCount;
    }

    // ease input
    const target = userIsControlling() ? yNormTarget : burnRateTarget;
    yNorm += (target - yNorm) * 0.05; // slightly slower smoothing for organic feel
    
    // ease x input for size control
    const xTarget = userIsControlling() ? xNormTarget : 0.5;
    xNorm += (xTarget - xNorm) * 0.05;

    // brightness from position: top => bright, bottom => dim
    const posB = 1 - yNorm; // 1 at top, 0 at bottom

    // flicker signal (low-frequency, flame-like)
    const base = 0.18 + 0.70 * posB;              // overall brightness range
    const s1 = Math.sin(t * (2.1 + 0.3*rand())) * 0.10;
    const s2 = Math.sin(t * 7.0) * 0.05;
    const s3 = Math.sin(t * 13.2) * 0.02;
    const jitter = (rand() - 0.5) * 0.03;
    const raw = clamp01(base + s1 + s2 + s3 + jitter);
    flicker += (raw - flicker) * 0.20;

    const W = canvas.width, H = canvas.height;
    const cx = W * 0.5;
    const cy = H * 0.42;

    // size responds to pointer height too (higher => bigger)
    const size = 0.55 + 0.65 * posB;
    
    // Size scaling: user x-coordinate overrides vote activity when controlling
    // Vote activity scaling: start small (0.5x), grow logarithmically
    // 0 votes = 0.5x, 10K votes = 1.0x, 100K votes = 2.0x, 1M+ votes = 4.0x
    let voteScale;
    if (userIsControlling()) {
      // User control: left = 0.3x, center = 1.0x, right = 3.0x
      voteScale = 0.3 + xNorm * 2.7;
    } else {
      voteScale = 0.5 + Math.max(0, voteActivityScale) * 0.5;
    }
    
    // Base star size (for text arc calculation, unaffected by vote scaling)
    const baseOuterR = Math.min(W,H) * 0.075 * size * (0.85 + 0.35*flicker);
    
    // Actual star size (scaled by vote activity)
    const outerR = baseOuterR * voteScale;
    
    // Organic breathing effect: combine multiple sine waves for flame-like pulsing
    const p1 = Math.sin(t * 0.7) * 0.03; // ~9 sec cycle (deep relaxed breathing)
    const p2 = Math.sin(t * 6.28) * 0.015; // 1 sec cycle
    const p3 = Math.sin(t * 11.3) * 0.005;
    const pNoise = (rand() - 0.5) * 0.01;
    const pulse = p1 + p2 + p3 + pNoise;
    
    // Base ratio 0.30 (thinner arms), plus the chaotic pulse
    const innerR = outerR * (0.30 + pulse);

    // background (cached gradient)
    ctx.clearRect(0,0,W,H);
    if (!cachedBgGradient || W !== lastW || H !== lastH) {
      cachedBgGradient = ctx.createRadialGradient(cx, cy, Math.min(W,H)*0.05, cx, cy, Math.min(W,H)*0.85);
      cachedBgGradient.addColorStop(0, "#0b0710");
      cachedBgGradient.addColorStop(1, "#020104");
      lastW = W;
      lastH = H;
    }
    ctx.fillStyle = cachedBgGradient;
    ctx.fillRect(0,0,W,H);

    // light pool around star (only really blooms when bright)
    const lit = smoothstep(0.35, 0.85, flicker);
    const glowR = outerR * (6.0 + 2.5*lit);
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, glowR);
    g.addColorStop(0, `rgba(255,230,180,${0.18 + 0.35*lit})`);
    g.addColorStop(0.25, `rgba(255,170,110,${0.08 + 0.20*lit})`);
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    // star body
    const twinkle = 0.75 + 0.35 * flicker;
    ctx.save();
    ctx.globalCompositeOperation = "lighter";

    starPath(cx, cy, outerR, innerR, starPoints);
    const starGrad = ctx.createRadialGradient(cx, cy - outerR*0.2, innerR*0.1, cx, cy, outerR*1.3);
    starGrad.addColorStop(0, `rgba(255,255,245,${0.95})`);
    starGrad.addColorStop(0.35, `rgba(255,235,200,${0.92})`);
    starGrad.addColorStop(0.75, `rgba(255,170,95,${0.85})`);
    starGrad.addColorStop(1, `rgba(90,35,20,${0.20})`);
    ctx.fillStyle = starGrad;
    ctx.globalAlpha = 0.75 + 0.25*twinkle;
    ctx.fill();

    // crisp outline (subtle)
    ctx.globalCompositeOperation = "source-over";
    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = Math.max(1, Math.min(W,H)*0.002);
    ctx.stroke();
    ctx.restore();

    // ---- TEXT: two-pass ----
    // Baseline "ink" pass: barely visible at bottom, readable at mid.
    const ink = 0.03 + 0.10 * smoothstep(0.10, 0.55, posB); // bottom ~0.03, mid+ ~0.13
    const fontPx = Math.floor(Math.min(W,H) * 0.069);

    const arcR = baseOuterR * 2.9;
    const topStart = -Math.PI * 0.95, topEnd = -Math.PI * 0.05;   // upper arc
    const botStart =  Math.PI * 0.05, botEnd =  Math.PI * 0.95;   // lower arc

    // dim ink (skip if nearly invisible)
    if (ink > 0.05) {
      drawTextOnArc(TOP_TEXT, cx, cy, arcR, topStart, topEnd, { alpha: ink, fill:"#3a3343", fontPx, glow:false, clockwise:true });
      drawTextOnArc(BOT_TEXT, cx, cy, arcR, botStart, botEnd, { alpha: ink, fill:"#3a3343", fontPx, glow:false, clockwise:false });
    }

    // lit pass: only shows when bright, and gets glow
    const litText = 0.55 * smoothstep(0.45, 0.95, flicker);
    if (litText > 0.01) {
      drawTextOnArc(TOP_TEXT, cx, cy, arcR, topStart, topEnd, { alpha: litText, fill:"#ffe2b8", fontPx, glow:true, clockwise:true });
      drawTextOnArc(BOT_TEXT, cx, cy, arcR, botStart, botEnd, { alpha: litText, fill:"#ffe2b8", fontPx, glow:true, clockwise:false });
    }

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
